# C++ 学习笔记
## 第一天：
```
1、函数重载

◼ 函数名相同，但参数个数不同、参数类型不同、参数顺序不同
◼ 注意：
	返回值类型与函数重载无关
	调用函数时，实参的隐式类型转换可能产生二义性

◼ 本质：
	采用了name mangling或者name decoration技术
	c++编译器默认会对符号名（变量名、函数名）进行改编、修饰。
	重载时会生成多个不同的函数名，不同的编译器（MSVC g++）有不同的生成的规则


2、extern "C"
◼ 由于C和C++编译规则的不同，在C、C++混合开发时，可能经常出现以下操作：
	C++ 调用C语言的API时，需要使用extern "C"修饰C语言的函数声明

3、c++允许设置默认参数，在调用时可以根据情况省略实参，规则如下：
	默认参数只能按照右到左的顺序。比如func(int a=20)、func(int b, int c=3);
	如果函数同时有声明、实现，默认参数只能放在函数声明中。
	默认参数的值可以是常量、全局符号（全局变量、函数名）
```
## 第二天
```
1、内联函数 （inline function）
 
◼ 使用inline修饰函数的声明或者实现，可以使其变成内联函数，建议声明和实现都增加inline修饰

◼ 特点：
	编译器会将函数调用直接展开为函数体代码
 	可以减少函数调用的开销
	会增大代码体积
	
◼ 注意：
	尽量不要内联超过10行代码的函数
	有些函数即使声明为inline，也不一定会被编译器内联，比如递归函数
	函数代码量不是很多，且调用频率比较高时可选用内联函数
	
◼ 内联函数和宏：
	内联函数和宏都可减少函数调用的内存开销，但是内联函数比宏多了语法检测
	
◼ 我们经常使用#ifndef、#define、#endif来防止头文件的内容被重复包含

◼ #pragma once可以防止整个文件的内容被重复包含

◼ 区别
	#ifndef、#define、#endif受C\C++标准的支持，不受编译器的任何限制
	有些编译器不支持#pragma once(较老编译器不支持，如GCC 3.4版本之前)，兼容性不够好
	#ifndef、#define、#endif可以针对一个文件中的部分代码，而#pragma once只能针对整个文件
 
 
2、引用(Reference)

◼ 在C语言中，使用指针(Pointer)可以间接获取、修改某个变量的值

◼ 在C++中，使用引用(Reference)可以起到跟指针类似的功能

◼ 注意点
	引用相当于是变量的别名(基本数据类型、枚举、结构体、类、指针、数组等，都可以有引用)
	对引用做计算，就是对引用所指向的变量做计算
	在定义的时候就必须初始化，一旦指向了某个变量，就不可以再改变，“从一而终”
	可以利用引用初始化另一个引用，相当于某个变量的多个别名
	不存在【引用的引用、指向引用的指针、引用数组】
	
◼ 引用存在的价值之一:比指针更安全、函数返回值可以被赋值


3、const是常量的意思，被其修饰的变量不可更改，如果修饰的是类、结构体（的指针），其成员也不可以被更改

◼ 以下5个指针分别是什么含义？
	int age=10;
	const int *p0=&age;  *p0是常量(age的值不可改变)，p0不是常量（p0可以再指向其他变量）
	int const *p1=&age;  *p1是常量(age的值不可改变)，p1不是常量（p0可以再指向其他变量）
	int * const p2=&age;  p2是常量(p2不可以再指向其他变量），*p2不是常量(age的值可改变)
	const int * const p3=&age; p3是常量(p3不可以再指向其他变量），*p3是常量(age的值不可改变)
	int const * const p4=&age; p4是常量(p4不可以再指向其他变量），*p4是常量(age的值不可改变)
	
◼ 以上指针的问题可以用以下结论来解决：
	const 修饰的是其右边的内容
	
◼ const引用的特点
	可以指向临时数据(常量、表达式、函数返回值等)
	可以指向不同类型的数据
	作为函数参数时(此规则也适用于const指针)
	可以接受const和非const实参(非const引用，只能接受非const实参)
	可以跟非const引用构成重载
	
◼ 当常引用指向了不同类型的数据时，会产生临时变量，即引用指向的并不是初始化时的那个变量


4、 汇编
◼ 汇编语言的种类
	8086汇编(16bit)
	x86汇编(32bit)
	x64汇编(64bit)
	ARM汇编(嵌入式、移动设备)
	......
◼ x64汇编根据编译器的不同，有2种书写格式
	Intel
	AT&T
◼ 汇编语言不区分大小写
 
4.1、x64汇编要点总结：
◼ mov dest, src
	将src的内容赋值给dest，类似于dest = src
◼ [ 地址值 ]
	中括号[ ]里面放的都是内存地址
◼ word是2字节，dword是4字节(double word)，qword是8字节(quad word)
◼ call 函数地址
	调用函数
◼ lea dest, [ 地址值 ]
	将地址值赋值给dest，类似于dest = 地址值
◼ ret
	函数返回
◼ xor op1, op2	
	将op1和op2异或的结果赋值给op1，类似于op1 = op1 ^ op2
◼ add op1, op2
	类似于op1 = op1 + op2
◼ sub op1, op2
	类似于op1 = op1 - op2
◼ inc op
	自增，类似于op = op + 1
◼ dec op
	自减，类似于op = op – 1
◼ jmp 内存地址
	跳转到某个内存地址去执行代码 j开头的一般都是跳转，大多数是带条件的跳转，一般跟test、cmp等指令配合使用
◼ 权威参考:Intel白皮书
	https://software.intel.com/en-us/articles/intel-sdm
◼ 一个变量的地址值，是它所有字节地址中的最小的那个地址值
```

#第三天
```
 面向对象---类
 C++中可以使用struct、class来定义一个类
 struct和class的区别：
 struct的默认成员权限是public
 class的默认成员权限是private
 类中的函数存放在内存中的代码区，所以类所占用的内存不包括函数的。
 this是指向当前对象的指针
 对象在调用成员函数的时候，会自动传入当前对象的内存地址赋值给this指针。
 
在栈空间分配了内存空间给person对象，这个person对象的内存会自动回收，不用管理。
	Person person;//这样就相当于创建了类实例person
	person.age=10;//以class创建的类,在类外部不能访问其成员变量。
    anotherPerson aPerson;
    //对象的内存布局：变量id的地址就是aPerson。
    aPerson.id=10;//对应的汇编代码：mov dword [ptr] [ebp-14h] 10
    aPerson.age=20;//对应的汇编代码：mov dword [ptr] [ebp-10h] 20
    aPerson.height=30;//对应的汇编代码：mov dword [ptr] [ebp-c0h] 30
    aPerson.display();//对应的汇编代码：call [028393920]
```

